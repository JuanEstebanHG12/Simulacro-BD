import pg from 'pg';
import { env } from "./env.js";

import fs from 'fs';
import csv from 'csv-parser';
import { PatientHistory } from '../models/patien_historial.js';

const { Pool } = pg;

const pool = new Pool({
    connectionString: env.postgresUri
});

async function createTables() {
    const client = await pool.connect();
    try {
        await client.query("BEGIN");

        //create table Document_type
        await client.query(`
            -- Document_Type
CREATE TABLE IF NOT EXISTS "Document_Type" (
    "id" INTEGER NOT NULL UNIQUE GENERATED BY DEFAULT AS IDENTITY,
    "name" VARCHAR(50) NOT NULL UNIQUE,
    PRIMARY KEY("id")
);
`)
        //create table specialties
        await client.query(`
            -- Specialty
CREATE TABLE IF NOT EXISTS "Specialty" (
    "id" INTEGER NOT NULL UNIQUE GENERATED BY DEFAULT AS IDENTITY,
    "name" VARCHAR(100) NOT NULL UNIQUE,
    PRIMARY KEY("id")
);
            `)

        //create table patients
        await client.query(`
            -- Patient
CREATE TABLE IF NOT EXISTS "Patient" (
    "id" INTEGER NOT NULL UNIQUE GENERATED BY DEFAULT AS IDENTITY,
    "document_number" VARCHAR(20) NOT NULL UNIQUE,
    "document_type_id" INTEGER NOT NULL,
    "email" VARCHAR(150) NOT NULL UNIQUE,
    "name" VARCHAR(255) NOT NULL,
    "phone" VARCHAR(10),
    "address" VARCHAR(150),
    PRIMARY KEY("id"),
    CONSTRAINT fk_patient_document_type FOREIGN KEY ("document_type_id")
        REFERENCES "Document_Type"("id")
        ON UPDATE NO ACTION ON DELETE NO ACTION
);
        `)



        //create table doctors
        await client.query(`
            -- Doctor
CREATE TABLE IF NOT EXISTS "Doctor" (
    "id" INTEGER NOT NULL UNIQUE GENERATED BY DEFAULT AS IDENTITY,
    "name" VARCHAR(255) NOT NULL,
    "email" VARCHAR(150) UNIQUE,
    "specialty_id" INTEGER NOT NULL,
    PRIMARY KEY("id"),
    CONSTRAINT fk_doctor_specialty FOREIGN KEY ("specialty_id")
        REFERENCES "Specialty"("id")
        ON UPDATE NO ACTION ON DELETE NO ACTION
);
            `)

        //create table insurance
        await client.query(`
            -- Insurance
CREATE TABLE IF NOT EXISTS "Insurance" (
    "id" INTEGER NOT NULL UNIQUE GENERATED BY DEFAULT AS IDENTITY,
    "name" VARCHAR(100) NOT NULL UNIQUE,
    "coverage_percentage" DECIMAL(5,2) NOT NULL,
    PRIMARY KEY("id")
);
            `
        )

        //create table Treatment
        await client.query(`
            CREATE TABLE IF NOT EXISTS "Treatment" (
    "id" INTEGER NOT NULL UNIQUE GENERATED BY DEFAULT AS IDENTITY,
    "code" VARCHAR(20) NOT NULL UNIQUE,
    "treatment_description" VARCHAR(255) NOT NULL,
    "treatment_cost" DECIMAL(10,2) NOT NULL,
    PRIMARY KEY("id")
);
            `
        )
        //create table appointments
        await client.query(`
            CREATE TABLE IF NOT EXISTS "Appointment" (
    "id" INTEGER NOT NULL UNIQUE GENERATED BY DEFAULT AS IDENTITY,
    "code" VARCHAR(20) NOT NULL UNIQUE,
    "appointment_date" TIMESTAMP NOT NULL,
    "patient_id" INTEGER NOT NULL,
    "doctor_id" INTEGER NOT NULL,
    "treatment_code" VARCHAR(20) NOT NULL,
    "amount_paid" DECIMAL(10,2) NOT NULL,
    "insurance_id" INTEGER NOT NULL,
    PRIMARY KEY("id"),
    CONSTRAINT fk_appointment_patient FOREIGN KEY ("patient_id")
        REFERENCES "Patient"("id")
        ON UPDATE NO ACTION ON DELETE NO ACTION,
    CONSTRAINT fk_appointment_doctor FOREIGN KEY ("doctor_id")
        REFERENCES "Doctor"("id")
        ON UPDATE NO ACTION ON DELETE NO ACTION,
    CONSTRAINT fk_appointment_treatment FOREIGN KEY ("treatment_code")
        REFERENCES "Treatment"("code")
        ON UPDATE NO ACTION ON DELETE NO ACTION,
    CONSTRAINT fk_appointment_insurance FOREIGN KEY ("insurance_id")
        REFERENCES "Insurance"("id")
        ON UPDATE NO ACTION ON DELETE NO ACTION
);
            `
        )


        await client.query('COMMIT')

    } catch (error) {
        console.error("Error creating tables", error);
        await client.query("ROLLBACK");

    } finally {
        client.release();
    }
}

async function insertData() {
    const client = await pool.connect();
    try {
        await client.query("BEGIN");

        //insert data into Document_Type
        await client.query(`
            INSERT INTO "Document_Type" ("name") VALUES ('CC'), ('CE'), ('TI'), ('PA')
            ON CONFLICT ("name")
            DO UPDATE SET
                name = EXCLUDED.name;
        `);

        const docType = await client.query(
            `SELECT id FROM "Document_Type" WHERE name = $1`,
            ['CC']
        );

        const documentTypeId = docType.rows[0].id;

        const result = [];
        await new Promise((resolve, reject) => {
            fs.createReadStream(env.fileDataCsv)
                .pipe(csv())
                .on("data", (data) => result.push(data))
                .on("end", resolve)
                .on("error", reject);
        });

        const counters = {
            patients: 0,
            doctors: 0,
            insurances: 0,
            appointments: 0,
            histories: 0
        };
        for (const row of result) {

            const patient = await client.query(`
                INSERT INTO "Patient" 
                ("document_number", "document_type_id", "email", "name", "phone", "address")
                VALUES ($1, $2, $3, $4, $5, $6)
                ON CONFLICT ("email")
                DO UPDATE SET
                    name = EXCLUDED.name,
                    phone = EXCLUDED.phone,
                    address = EXCLUDED.address
                RETURNING id,xmax
            `, [
                Math.floor(Math.random() * 100000000),
                documentTypeId,
                row.patient_email,
                row.patient_name,
                row.patient_phone,
                row.patient_address
            ]);
            //insert data into Specialty
            const specialty = await client.query(`
                INSERT INTO "Specialty" ("name")
                VALUES ($1)
                ON CONFLICT ("name")
                DO UPDATE SET name = EXCLUDED.name
                RETURNING id
            `, [row.specialty]);

            const specialtyId = specialty.rows[0].id;

            //insert data into Doctor
            const doctor = await client.query(`
                INSERT INTO "Doctor"
                ("name", "email", "specialty_id")
                VALUES ($1, $2, $3)
                ON CONFLICT ("email")
                DO UPDATE SET
                    name = EXCLUDED.name,
                    specialty_id = EXCLUDED.specialty_id
                RETURNING id, xmax
            `, [
                row.doctor_name,
                row.doctor_email,
                specialtyId
            ]);

            const doctorId = doctor.rows[0].id;

            //insert data into Insurance
            const insurance = await client.query(`
                INSERT INTO "Insurance" ("name", "coverage_percentage")
                VALUES ($1, $2)
                ON CONFLICT ("name")
                DO UPDATE SET coverage_percentage = EXCLUDED.coverage_percentage
                RETURNING id, xmax
            `, [row.insurance_provider, row.coverage_percentage]);

            //insert data into Treatment
            const treatment = await client.query(`
                INSERT INTO "Treatment"
                ("code", "treatment_description", "treatment_cost")
                VALUES ($1, $2, $3)
                ON CONFLICT ("code")
                DO UPDATE SET
                    treatment_description = EXCLUDED.treatment_description,
                    treatment_cost = EXCLUDED.treatment_cost
                RETURNING code;
            `, [
                row.treatment_code?.trim(),
                row.treatment_description?.trim(),
                row.treatment_cost,
            ]);

            const treatmentId = treatment.rows[0].code;
            //insert data into Appointment
            const appointment = await client.query(`
                INSERT INTO "Appointment" ("code", "appointment_date", "patient_id", "doctor_id", "treatment_code", "amount_paid", "insurance_id") VALUES ($1, $2, $3, $4, $5, $6, $7)
                ON CONFLICT ("code")
                DO UPDATE SET
                    code = EXCLUDED.code,
                    insurance_id = EXCLUDED.insurance_id
                RETURNING id, xmax;
            `, [row.appointment_id, row.appointment_date, patient.rows[0].id, doctor.rows[0].id, treatment.rows[0].code, row.amount_paid, insurance.rows[0].id])

            //En la query, retrorno tambien xmax si este valor es === 0 es porque con el ON CONFLICT se creo si es diferente, es porque se actualizó, entonces si se creó... sumo
            if (appointment.rows[0].xmax === '0') counters.appointments++
            if (patient.rows[0].xmax === '0') counters.patients++
            if (doctor.rows[0].xmax === '0') counters.doctors++
            if (insurance.rows[0].xmax === '0') counters.insurances++


            //consultar si el email ya existe
            const existingHistory = await PatientHistory.findOne({
                patientEmail: row.patient_email
            });
            
            await PatientHistory.findOneAndUpdate(
                { patientEmail: row.patient_email },
                {
                    $setOnInsert: {
                        patientEmail: row.patient_email,
                        patientName: row.patient_name
                    },
                    $push: {
                        appointments: {
                            appointmentId: row.appointment_id,
                            date: row.appointment_date,
                            doctorName: row.doctor_name,
                            doctorEmail: row.doctor_email,
                            specialty: row.specialty,
                            treatmentCode: row.treatment_code,
                            treatmentDescription: row.treatment_description,
                            treatmentCost: row.treatment_cost,
                            insuranceProvider: row.insurance_provider,
                            coveragePercentage: row.coverage_percentage,
                            amountPaid: row.amount_paid
                        }
                    }
                },
                { upsert: true }
            );
            if (!existingHistory) counters.histories++; //si no existe, suma a historias
        }
        await client.query('COMMIT')
        return counters

    } catch (error) {
        console.error("Error inserting data", error);
        await client.query("ROLLBACK");

    } finally {
        client.release();
    }
}

export { createTables, insertData, pool }